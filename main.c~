#include "shell.h"

/**
 * main - run basic loop of shell
 *              it is the entry of the code
 * @argc: counts the argument
 * @argv: the double pointer of the arguments
 * @env: the dbl pointer of the enviroment variables
 *
 * Return: 0 if successful OR 1 if failure
 */

int main(int argc, char **argv, char **env)
{int i, err = 0, line = 0, ststr;
	char *cmd, **sargs, *buff;

	while (argc)
	{line++;
		buff = theprepbuff();
		if (buff == NULL)
			break;
		else if (buff[0] == '\0')
			continue;
		else if (!(_cstrcmpfun(buff, "exit")) && _cstrlenfun(buff) > 3)
		{thexitbuiltin(buff, argv, line, &err);
			continue; }
		else if (!(_cstrcmpfun(buff, "env")) && _cstrlenfun(buff) > 2)
		{the_envbltin(buff, env);
			continue; }
		sargs = thetokenizer(buff, ' '), free(buff);
		cmd = xcmd(argv, env, sargs, line, &err);
		if (cmd != NULL)
		{
			if (err != 126)
			{zchexe(cmd, sargs, env, &err);
				wait(&ststr), err = WEXITSTATUS(ststr); }
			else
				errorprint(argv, sargs, line, err);
			free(cmd); }
		for (i = 0; sargs[i] != NULL; i++)
			free(sargs[i]);
		free(sargs); }
	return (err);
}

/**
 * theprepbuff - this prepares the
 *              buffer for the shell
 * Return: always returns the buffer
 *          that is prepped for shell
 */

char *theprepbuff()
{
	int i, res;
	size_t buffsize = 1024;
	char *buff = malloc(sizeof(char) * buffsize);

	if (buff == NULL)
		exit(1);
	if (isatty(STDIN_FILENO))
		_theprintf(STDOUT_FILENO, "$ ");
	res = getline(&buff, &buffsize, stdin);
	if (res == -1)
	{
		free(buff);
		if (isatty(STDIN_FILENO))
			_theprintf(STDOUT_FILENO, "\n");
		return (NULL);
	}
	for (i = 0; buff[i] != '\n' && buff[i] != '\0' &&
		(buff[i] != '#' || ((i > 0) ? (buff[i - 1] != ' ') : 0)); i++)
		;
	buff[i] = '\0';
	buff = trimerbuff(buff);
	return (buff);
}

/**
 * zchexe - the function that calls fork
 *          the child and execute the command
 * @cmd: the subject command to be executed
 * @sargs: the dbl pointer containing
 *          arguments for command
 * @env: dbl pointer containing
 *          enviromental variables
 * @err: the custom errno
 *
 * Return: 0 if successful OR -1 if failure
 */

void zchexe(char *cmd, char **sargs, char **env, int *err)
{
	int cpid;

	cpid = fork();
	if (cpid == -1)
	{
		_theprintf(STDERR_FILENO, "The Fork failed");
		*err = 1;
	}
	else if (cpid == 0)
		execve(cmd, sargs, env);
}

/**
 * xcmd - this is the function
 *              to get command to be executed
 * @argv: dbl pointer containing
 *          array of arguments
 * @env: it is the double pointer that contains
 *          enviromental variables
 * @sargs: sargs is the doubleb pointer that contains
 *          the tokenized shell arguments
 * @line: It is the line number
 * @err: custom errno
 *
 * Return: returns the concatenated pointer
 *          containing working command
 */

char *xcmd(char **argv, char **env, char **sargs, int line, int *err)
{
	struct stat ststr;
	int i, cenv = 0;
	char *senv, **spath, *cat;

	while (_cstrncmpfun(env[cenv], "PATH", 4))
		cenv++;
	senv = malloc(sizeof(char) * (_cstrlenfun(env[cenv] + 5) + 1));
	if (senv == NULL)
		return (NULL);
	_cstrcpyfun(senv, (env[cenv] + 5));
	spath = thetokenizer(senv, ':');
	for (i = 0; spath[i] != NULL; i++)
	{
	cat = malloc(sizeof(char) * (_strlen(spath[i]) + _strlen(sargs[0]) + 2));
		if (cat == NULL)
		{free(senv);
			return (NULL); }
		_cstrcpyfun(cat, spath[i]);
		if (spath[i][0] != '\0')
			_cstrcatfun(cat, "/");
		_cstrcatfun(cat, sargs[0]);
		*err = stat(cat, &ststr);
		if (*err == 0)
			break;
		free(cat);
	}
	if (*err == -1)
		cat = latepath(sargs, argv, line);
	if (cat != NULL)
	{
		if (access(cat, X_OK) == -1)
			*err = 126;
	}
	else
		*err = 127;
	free(senv);
	for (i = 0; spath[i] != NULL; i++)
		free(spath[i]);
	free(spath);
	return (cat);
}
