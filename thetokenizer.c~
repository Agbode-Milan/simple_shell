#include "shell.h"

/**
 * thetokenizer - this is the function that will parses
 *                  the buff into smallest tokens
 * @buff: the pointer that has
 *          to be tokenized
 * @delim: delim is the delimiter to split at
 *
 * Return: returns the pointer to array of tokens
 */

char **thetokenizer(char *buff, char delim)
{
	int i, k, j, d, len = _cstrlenfun(buff);
	char **toks = malloc(sizeof(char *) * 1024);

	for (i = 0, k = 0, j = 0; i <= len; i++)
	{
		if (buff[i] == delim || buff[i] == '\0')
		{
			toks[k] = malloc(sizeof(char) * (i - j + 1));
			for (d = 0; j + d < i; d++)
				toks[k][d] = buff[j + d];
			toks[k][d] = '\0';
			j = i + 1;
			k++;
		}
	}
	toks[k] = NULL;
	return (toks);
}

/**
 * expfun - this function aims to expand a relative
 *          path to an absolute path
 * @rel: rel is the absolute relative path to expand
 * @dest: dest is definate buffer
 *          to save absolute path to
 */
void expfun(char *rel, char *dest)
{
	char *curr, *next;
	char *tmp = malloc(sizeof(char) * 1024);

	if (!(_cstrncmpfun(rel, "./", 2)))
	{
		getcwd(dest, 1024);
		_cstrcatfun(dest, rel + 1);
	}
	else if (!(_cstrncmpfun(rel, "../", 2)))
	{
		curr = strtok(getcwd(tmp, 1024), "/");
		next = strtok(NULL, "/");
		if (curr != NULL)
		{
			_cstrcpyfun(dest, "/");
			_cstrcatfun(dest, curr);
		}
		while (next != NULL)
		{
			curr = next;
			next = strtok(NULL, "/");
			if (next != NULL)
			{
				_cstrcatfun(dest, "/");
				_cstrcatfun(dest, curr);
			}
		}
		_cstrcatfun(dest, rel + 2);
	}
	free(tmp);
}

/**
 * trimerbuff - this function aims to trim the
 *              spaces from the beginning and end of buff
 * @buff: buff is the buff to be trimed
 *
 * Return: returns the pointer to realloced
 *          buff with trimmed result
 */
char *trimerbuff(char *buff)
{
	int i, c1, c2 = 0, l = _cstrlenfun(buff);
	char *newbuff;

	for (c1 = 0; buff[c1] == ' '; c1++)
		;
	for (i = l - 1; buff[i] == ' '; i--, c2++)
		;
	buff[i + 1] = '\0';

	newbuff = malloc(sizeof(char) * (l - (c1 + c2) + 1));

	_cstrcpyfun(newbuff, buff + c1);
	free(buff);
	return (newbuff);
}

/**
 * latepath - checks for the non-path files
 *
 * @sargs: this are the shell arguments
 * @argv: subject arguments
 * @line: our line count
 *
 * Return: always returns the pointer
 *          to new path
 */
char *latepath(char **sargs, char **argv, int line)
{
	struct stat ststr;
	char *cat;
	int res;

	cat = malloc(sizeof(char) * 1024);
	cat[0] = '\0';
	if (!(_cstrncmpfun(sargs[0], "./", 2)) || !(_cstrncmpfun(sargs[0], "../", 3)))
		expfun(sargs[0], cat);
	else if (!(_strncmp(sargs[0], "/", 1)))
		_cstrcpyfun(cat, sargs[0]);
	res = stat(cat, &ststr);
	if (res == -1)
	{
		errorprint(argv, sargs, line, 127);
		free(cat);
		cat = NULL;
	}

	return (cat);
}

/**
 * errorprinter - this function aims at printing
 *                  error messages
 * @argv: program arguments
 * @line: line number
 *
 * @sargs: command arguments
 * @err: the subject error number
 */
void errorprinter(char **argv, char **sargs, int line, int err)
{
	char *num = malloc(1024);
	char *str;

	_theitoa(line, num, 10);
	str = malloc(sizeof(char) *
		(_cstrlenfun(argv[0]) + _cstrlenfun(num) + _cstrlenfun(sargs[0]) + 5));
	_cstrcpyfun(str, argv[0]);
	_cstrcatfun(str, ": ");
	_cstrcatfun(str, num);
	_cstrcatfun(str, ": ");
	_cstrcatfun(str, sargs[0]);

	if (err == 127)
		_theprintf(STDERR_FILENO, "%s: not found\n", str);
	else if (err == 126)
		_theprintf(STDERR_FILENO, "%s: Permission denied\n", str);
	else if (err == 666)
		_theprintf(STDERR_FILENO, "%s: Illegal number: %s\n", str, sargs[1]);

	free(num);
	free(str);
}
